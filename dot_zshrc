# ~/.zshrc - NKERMANI - Hybrid Config 2026
###############################################################################

# 1. DÃ‰TECTION OS (Rapide)
UNAME_S=$(uname -s)
if [[ "$UNAME_S" == "Darwin" ]]; then
    OS_TYPE="macos"
elif grep -qiE 'microsoft|wsl' /proc/version 2>/dev/null; then
    OS_TYPE="wsl2"
else
    OS_TYPE="linux"
fi

export NK_DIR="$HOME/.nkermani"
export NK_APPS="$NK_DIR/apps"
export NK_BIN="$NK_DIR/bin"

# 2. PATH & ENV
export ZSH="$NK_APPS/ohmyzsh"
export NVM_DIR="$HOME/.nvm"

typeset -U path
path=($NK_BIN $HOME/.local/bin $HOME/.opencode/bin $HOME/.cargo/bin /usr/local/bin $path)

# 3. OH-MY-ZSH (Chargement silencieux)
ZSH_THEME="robbyrussell"
plugins=(git zsh-syntax-highlighting zsh-autosuggestions auto-notify you-should-use zsh-history-substring-search)
[ -f "$ZSH/oh-my-zsh.sh" ] && source "$ZSH/oh-my-zsh.sh"

# 4. LOGIQUE VS CODE (WSL2)
if [[ "$OS_TYPE" == "wsl2" ]]; then
    unalias code c 2>/dev/null
    export VSCODE_EXE="/mnt/c/Users/kerma/AppData/Local/Programs/Microsoft VS Code/Code.exe"

    code() {
        # On encapsule tout dans un subshell ( ) pour cacher le job ID
        # On redirige tout vers /dev/null
        # Le & Ã  la fin du subshell dÃ©tache naturellement le processus
        ( "$VSCODE_EXE" --remote wsl+Ubuntu-22.04 "${@:-.}" &> /dev/null & )
    }
    alias c='code'
fi

# 5. SMART-EDITOR (GÃ©nÃ©ration ultra-robuste)
W_CODE_EXE="/mnt/c/Users/kerma/AppData/Local/Programs/Microsoft VS Code/Code.exe"

mkdir -p "$NK_BIN"
cat << 'EOF' > "$NK_BIN/smart-editor"
#!/usr/bin/env bash

# 1. Gestion de l'argument par dÃ©faut
if [ $# -eq 0 ]; then
    set -- "."
fi

W_CODE="/mnt/c/Users/kerma/AppData/Local/Programs/Microsoft VS Code/Code.exe"

# 2. PrioritÃ© WSL2
# On simplifie la dÃ©tection : si grep trouve 'wsl', on entre dans le bloc
if grep -qiE 'microsoft|wsl' /proc/version 2>/dev/null; then
    if [[ -f "$W_CODE" ]]; then
        "$W_CODE" --remote wsl+Ubuntu-22.04 "$@" &> /dev/null &
        exit 0
    fi
fi

# 3. Fallbacks (42, Linux Natif, macOS)
if command -v code >/dev/null 2>&1; then
    exec code "$@"
elif command -v nvim >/dev/null 2>&1; then
    exec nvim "$@"
else
    exec vi "$@"
fi
EOF
chmod +x "$NK_BIN/smart-editor"

export EDITOR="smart-editor"
export VISUAL="smart-editor"
# Alias Ã©diteurs
alias n='nvim'
alias v='vim'
alias e='smart-editor'
alias c='smart-editor'
alias edit='smart-editor'
alias clear='clear -x'

# 6. FONCTIONS PERSO & AI
ai() {
  local dir=$(fd --type d --hidden --exclude .git . ~ | fzf --prompt="ó°š Launch OpenCode in: ")
  [[ -n "$dir" ]] && cd "$dir" && opencode
}
alias aichat='opencode chat'
alias aip='opencode project'
alias aie='opencode explain'

# CAT / BAT
if command -v bat >/dev/null 2>&1; then
    alias cat='bat --style=plain --paging=never'
elif command -v batcat >/dev/null 2>&1; then
    alias cat='batcat --style=plain --paging=never'
fi

_get_viewer() {
  command -v bat >/dev/null 2>&1 && echo "bat --color=always --style=numbers" || \
  command -v batcat >/dev/null 2>&1 && echo "batcat --color=always --style=numbers" || \
  echo "cat"
}


# Navigation rapide dans le dossier courant
f() {
    local dir
    if [[ "$1" == "-a" ]]; then
        # Affiche TOUT (y compris les .files et .directories)
        dir=$(fd --type d --hidden --exclude .git | fzf --prompt="ðŸ“‚ Go to (All): ")
    else
        # Cache les dossiers commenÃ§ant par un point (ex: .config, .local)
        dir=$(fd --type d --hidden --exclude .git --exclude '.*' | fzf --prompt="ðŸ“‚ Go to: ")
    fi

    [[ -n "$dir" ]] && cd "$dir"
}

# Navigation rapide dans le HOME
fr() {
    local dir
    if [[ "$1" == "-a" ]]; then
        # Affiche TOUT dans le HOME
        dir=$(fd --type d --hidden --exclude .git . ~ | fzf --prompt="ðŸ  Go to Home (All): ")
    else
        # Cache les .files du HOME
        dir=$(fd --type d --hidden --exclude .git --exclude '.*' . ~ | fzf --prompt="ðŸ  Go to Home: ")
    fi

    [[ -n "$dir" ]] && cd "$dir"
}

# FE : Find & Edit (Current Path)
fe() {
    local v=$(_get_viewer)
    local fd_cmd=("fd" "-a" "--type" "f" "--exclude" ".git")
    local query=""

    # Gestion du flag -a
    if [[ "$1" == "-a" ]]; then
        fd_cmd+=("--hidden" "--no-ignore")
        query="$2" # On prend le mot suivant comme recherche fzf
    else
        query="$1"
    fi

    local file=$("${fd_cmd[@]}" | fzf --query "$query" --preview "$v {}")
    [[ -n "$file" ]] && smart-editor "$file"
}

# FRE : Find & Edit (Home Path)
fre() {
    local v=$(_get_viewer)
    local fd_cmd=("fd" "-a" "--type" "f" "--exclude" ".git")
    local query=""

    if [[ "$1" == "-a" ]]; then
        fd_cmd+=("--hidden" "--no-ignore")
        query="$2"
    else
        query="$1"
    fi

    # On cherche dans le Home (~)
    local file=$("${fd_cmd[@]}" . ~ | fzf --query "$query" --preview "$v {}")
    [[ -n "$file" ]] && smart-editor "$file"
}

# --- Ouverture avec Code (smart-editor) ---
fo() {
    local dir
    local cmd="fd --type d --hidden --exclude .git"
    [[ "$1" != "-a" ]] && cmd+=" --exclude '.*'"
    dir=$(eval "$cmd" | fzf --prompt="ðŸ’» Open with Code: ")
    # Utilise smart-editor pour gÃ©rer WSL/42/Linux
    [[ -n "$dir" ]] && smart-editor "$dir"
}

fro() {
    local dir
    local cmd="fd --type d --hidden --exclude .git . ~"
    [[ "$1" != "-a" ]] && cmd+=" --exclude '.*'"
    dir=$(eval "$cmd" | fzf --prompt="ðŸ’» Open Home folder with Code: ")
    [[ -n "$dir" ]] && smart-editor "$dir"
}

_get_viewer() {
    if command -v bat >/dev/null 2>&1; then
        echo "bat --color=always --style=numbers --line-range :500"
    elif command -v batcat >/dev/null 2>&1; then
        echo "batcat --color=always --style=numbers --line-range :500"
    else
        echo "cat"
    fi
}

# FZF SEARCH FUNCTIONS
fcat() { local v=$(_get_viewer); local f=$(fd --type f --hidden --exclude .git | fzf --preview "$v {}"); [[ -n "$f" ]] && cat "$f"; }
vf()   { local v=$(_get_viewer); local f=$(fd --type f --hidden --exclude .git | fzf --preview "$v {}"); [[ -n "$f" ]] && smart-editor "$f"; }
vfg()  { local v=$(_get_viewer); local f=$(fd --type f --hidden --exclude .git . ~ | fzf --preview "$v {}"); [[ -n "$f" ]] && smart-editor "$f"; }


# 7. INITIALISATIONS OPTIMISÃ‰ES (Lazy-loading)
# FZF & Zoxide
[ -n "$commands[fzf]" ] && source <(fzf --zsh 2>/dev/null || fzf --bash 2>/dev/null)
[ -n "$commands[zoxide]" ] && eval "$(zoxide init zsh)"

# NVM Lazy-load : Ne charge NVM que quand tu tapes 'nvm', 'node' ou 'npm'
if [ -s "$NVM_DIR/nvm.sh" ]; then
    nvm() {
        unfunction nvm node npm
        source "$NVM_DIR/nvm.sh"
        nvm "$@"
    }
    node() {
        unfunction nvm node npm
        source "$NVM_DIR/nvm.sh"
        node "$@"
    }
    npm() {
        unfunction nvm node npm
        source "$NVM_DIR/nvm.sh"
        npm "$@"
    }
fi

[ -f "$HOME/.cargo/env" ] && source "$HOME/.cargo/env"

# 8. ESTHÃ‰TIQUE
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=#808080'
bindkey '^?' backward-delete-char
