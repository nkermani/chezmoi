# ~/.zshrc - NKERMANI - Hybrid Config 2026
###############################################################################

# 1. DÃ‰TECTION OS (Rapide)
UNAME_S=$(uname -s)
if [[ "$UNAME_S" == "Darwin" ]]; then
    OS_TYPE="macos"
elif grep -qiE 'microsoft|wsl' /proc/version 2>/dev/null; then
    OS_TYPE="wsl2"
else
    OS_TYPE="linux"
fi

export NK_DIR="$HOME/.nkermani"
export NK_APPS="$NK_DIR/apps"
export NK_BIN="$NK_DIR/bin"

# 2. PATH & ENV
export ZSH="$NK_APPS/ohmyzsh"
export NVM_DIR="$HOME/.nvm"
export ZSH_CUSTOM="$ZSH/custom"

if [[ "$UNAME_S" == "Darwin" ]]; then
    # Ajoute les chemins standards de Homebrew et de VS Code
    export PATH="/usr/local/bin:/opt/homebrew/bin:$PATH"
    export PATH="/Applications/Visual Studio Code.app/Contents/Resources/app/bin:$PATH"
fi
typeset -U path
path=($NK_BIN $HOME/.local/bin $HOME/.opencode/bin $HOME/.cargo/bin /usr/local/bin $path)

# 2. Vos dossiers perso (en fin de liste pour ne pas masquer les binaires systÃ¨me essentiels)
export PATH="$NK_BIN:$PATH"



# 3. OH-MY-ZSH (Chargement silencieux)
ZSH_THEME="robbyrussell"
plugins=(git zsh-syntax-highlighting zsh-autosuggestions auto-notify you-should-use zsh-history-substring-search)
[ -f "$ZSH/oh-my-zsh.sh" ] && source "$ZSH/oh-my-zsh.sh"

# 4. LOGIQUE VS CODE (WSL2)
if [[ "$OS_TYPE" == "wsl2" ]]; then
    unalias code c 2>/dev/null
    export VSCODE_EXE="/mnt/c/Users/kerma/AppData/Local/Programs/Microsoft VS Code/Code.exe"

    code() {
        # On encapsule tout dans un subshell ( ) pour cacher le job ID
        # On redirige tout vers /dev/null
        # Le & Ã  la fin du subshell dÃ©tache naturellement le processus
        ( "$VSCODE_EXE" --remote wsl+Ubuntu-22.04 "${@:-.}" &> /dev/null & )
    }
    alias c='code'
fi

# 5. SMART-EDITOR
mkdir -p "$NK_BIN"
cat << 'EOF' > "$NK_BIN/smart-editor"
#!/usr/bin/env bash

# 1. Arguments par dÃ©faut
[ $# -eq 0 ] && set -- "."

# Chemins spÃ©cifiques
W_CODE="/mnt/c/Users/kerma/AppData/Local/Programs/Microsoft VS Code/Code.exe"
# Zed sur macOS ou Linux natif est souvent dans le PATH,
# mais on check les chemins standards.

# 2. Logique WSL2 (PrioritÃ© Windows si installÃ©)
if grep -qiE 'microsoft|wsl' /proc/version 2>/dev/null; then
    # Note: Zed n'a pas encore de mode --remote WSL officiel comme VS Code,
    # on utilise donc VS Code pour le moment sur WSL pour garder l'intÃ©gration Linux.
    if [[ -f "$W_CODE" ]]; then
        "$W_CODE" --remote wsl+Ubuntu-22.04 "$@" &> /dev/null &
        exit 0
    fi
fi

if command -v nvim >/dev/null 2>&1; then
    exec nvim "$@"
elif command -v code >/dev/null 2>&1; then
    exec code "$@"
elif command -v zed >/dev/null 2>&1; then
    exec zed "$@"
elif command -v zed-editor >/dev/null 2>&1; then
    exec zed-editor "$@"
else
    exec vi "$@"
fi
EOF
chmod +x "$NK_BIN/smart-editor"

export EDITOR="smart-editor"
export VISUAL="smart-editor"

# Alias Ã©diteurs
alias z='zed'
alias edit='smart-editor'
alias e='smart-editor'
alias c='code'
alias v='vim'
alias n='nvim'

alias clear='clear -x'

# 6. FONCTIONS PERSO & AI
ai() {
  local search_cmd
  local hidden_flag=""

  # Gestion des arguments
  if [[ "$1" == "-a" ]]; then
    # On autorise les dossiers cachÃ©s (sauf .git)
    search_cmd="fd --type d --hidden --exclude .git ."
  elif [[ -n "$1" ]]; then
    # Si un argument direct est passÃ© (ex: ai mon_dossier)
    opencode "$1"
    return
  else
    # Par dÃ©faut : dossiers visibles uniquement
    search_cmd="fd --type d ."
  fi

  local target=$(eval "$search_cmd" | fzf \
    --prompt="ó°š OpenCode (Local): " \
    --header="Select a folder to start agent")

  [[ -n "$target" ]] && cd "$target" && opencode .
}

# air : Recherche globale depuis le HOME (~/)
# air -a : Recherche globale incluant les dossiers cachÃ©s
air() {
  local search_cmd
  if [[ "$1" == "-a" ]]; then
    search_cmd="fd --type d --hidden --exclude .git . ~"
  else
    search_cmd="fd --type d . ~"
  fi

  local target=$(eval "$search_cmd" | fzf \
    --prompt="ó°š OpenCode (Global ~/): " \
    --header="Search folders from home")

  [[ -n "$target" ]] && cd "$target" && opencode .
}

# Alias pour l'option -a (ouvre tout, mÃªme les fichiers cachÃ©s)
alias ai-all='ai'
alias aichat='opencode chat'
alias aip='opencode project'
alias aie='opencode explain'

# CAT / BAT
if command -v bat >/dev/null 2>&1; then
    alias cat='bat --style=plain --paging=never'
elif command -v batcat >/dev/null 2>&1; then
    alias cat='batcat --style=plain --paging=never'
fi

_get_viewer() {
  command -v bat >/dev/null 2>&1 && echo "bat --color=always --style=numbers" || \
  command -v batcat >/dev/null 2>&1 && echo "batcat --color=always --style=numbers" || \
  echo "cat"
}

# Navigation rapide dans le dossier courant
f() {
    local dir
    if [[ "$1" == "-a" ]]; then
        # Affiche TOUT (y compris les .files et .directories)
        dir=$(fd --type d --hidden --exclude .git | fzf --prompt="ðŸ“‚ Go to (All): ")
    else
        # Cache les dossiers commenÃ§ant par un point (ex: .config, .local)
        dir=$(fd --type d --hidden --exclude .git --exclude '.*' | fzf --prompt="ðŸ“‚ Go to: ")
    fi

    [[ -n "$dir" ]] && cd "$dir"
}

# Navigation rapide dans le HOME
fr() {
    local dir
    if [[ "$1" == "-a" ]]; then
        # Affiche TOUT dans le HOME
        dir=$(fd --type d --hidden --exclude .git . ~ | fzf --prompt="ðŸ  Go to Home (All): ")
    else
        # Cache les .files du HOME
        dir=$(fd --type d --hidden --exclude .git --exclude '.*' . ~ | fzf --prompt="ðŸ  Go to Home: ")
    fi

    [[ -n "$dir" ]] && cd "$dir"
}

# FE : Find & Edit (Current Path)
fe() {
    local v=$(_get_viewer)
    local fd_cmd=("fd" "-a" "--type" "f" "--exclude" ".git")
    local query=""

    # Gestion du flag -a
    if [[ "$1" == "-a" ]]; then
        fd_cmd+=("--hidden" "--no-ignore")
        query="$2" # On prend le mot suivant comme recherche fzf
    else
        query="$1"
    fi

    local file=$("${fd_cmd[@]}" | fzf --query "$query" --preview "$v {}")
    [[ -n "$file" ]] && smart-editor "$file"
}

# FRE : Find & Edit (Home Path)
fre() {
    local v=$(_get_viewer)
    local fd_cmd=("fd" "-a" "--type" "f" "--exclude" ".git")
    local query=""

    if [[ "$1" == "-a" ]]; then
        fd_cmd+=("--hidden" "--no-ignore")
        query="$2"
    else
        query="$1"
    fi

    # On cherche dans le Home (~)
    local file=$("${fd_cmd[@]}" . ~ | fzf --query "$query" --preview "$v {}")
    [[ -n "$file" ]] && smart-editor "$file"
}

# --- Ouverture avec Code (smart-editor) ---
fo() {
    local dir
    local cmd="fd --type d --hidden --exclude .git"
    [[ "$1" != "-a" ]] && cmd+=" --exclude '.*'"
    dir=$(eval "$cmd" | fzf --prompt="ðŸ’» Open with Code: ")
    # Utilise smart-editor pour gÃ©rer WSL/42/Linux
    [[ -n "$dir" ]] && smart-editor "$dir"
}

fro() {
    local dir
    local cmd="fd --type d --hidden --exclude .git . ~"
    [[ "$1" != "-a" ]] && cmd+=" --exclude '.*'"
    dir=$(eval "$cmd" | fzf --prompt="ðŸ’» Open Home folder with Code: ")
    [[ -n "$dir" ]] && smart-editor "$dir"
}

_get_viewer() {
    if command -v bat >/dev/null 2>&1; then
        echo "bat --color=always --style=numbers --line-range :500"
    elif command -v batcat >/dev/null 2>&1; then
        echo "batcat --color=always --style=numbers --line-range :500"
    else
        echo "cat"
    fi
}

# FZF SEARCH FUNCTIONS
fcat() { local v=$(_get_viewer); local f=$(fd --type f --hidden --exclude .git | fzf --preview "$v {}"); [[ -n "$f" ]] && cat "$f"; }
vf()   { local v=$(_get_viewer); local f=$(fd --type f --hidden --exclude .git | fzf --preview "$v {}"); [[ -n "$f" ]] && smart-editor "$f"; }
vfg()  { local v=$(_get_viewer); local f=$(fd --type f --hidden --exclude .git . ~ | fzf --preview "$v {}"); [[ -n "$f" ]] && smart-editor "$f"; }

# 7. INITIALISATIONS OPTIMISÃ‰ES (Lazy-loading)
# FZF & Zoxide
[ -n "$commands[fzf]" ] && source <(fzf --zsh 2>/dev/null || fzf --bash 2>/dev/null)
[ -n "$commands[zoxide]" ] && eval "$(zoxide init zsh)"

export FZF_DEFAULT_COMMAND='fd --type f --absolute-path'
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"

# Dans ton .zshrc
if [ -d "/goinfre/$USER/.nvm" ]; then
    export NVM_DIR="/goinfre/$USER/.nvm"
else
    export NVM_DIR="$HOME/.nkermani/apps/nvm"
fi
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"

# NVM Lazy-load : Ne charge NVM que quand tu tapes 'nvm', 'node' ou 'npm'
if [ -s "$NVM_DIR/nvm.sh" ]; then
    nvm() {
        unfunction nvm node npm
        source "$NVM_DIR/nvm.sh"
        nvm "$@"
    }
    node() {
        unfunction nvm node npm
        source "$NVM_DIR/nvm.sh"
        node "$@"
    }
    npm() {
        unfunction nvm node npm
        source "$NVM_DIR/nvm.sh"
        npm "$@"
    }
fi

[ -f "$HOME/.cargo/env" ] && source "$HOME/.cargo/env"

# 8. ESTHÃ‰TIQUE
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=#808080'
bindkey '^?' backward-delete-char

# --- Section Notes ---
export NOTES_DIR="$NK_DIR/notes"

# On ne tente un pull que si c'est vraiment un repo git
if [ -d "$NOTES_DIR/.git" ]; then
    ( builtin cd "$NOTES_DIR" && git pull --quiet &> /dev/null & )
fi

alias brain="smart-editor $NOTES_DIR"
alias cdn="cd $NOTES_DIR"
