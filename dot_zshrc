# ~/.zshrc - NKERMANI - Hybrid Config 2026
###############################################################################

# 1. DÃ‰TECTION OS (Rapide)
UNAME_S=$(uname -s)
if [[ "$UNAME_S" == "Darwin" ]]; then
    OS_TYPE="macos"
elif grep -qiE 'microsoft|wsl' /proc/version 2>/dev/null; then
    OS_TYPE="wsl2"
else
    OS_TYPE="linux"
fi

export NK_DIR="$HOME/.nkermani"
export NK_APPS="$NK_DIR/apps"
export NK_BIN="$NK_DIR/bin"

# Fallback if TERM is unknown or forced to something missing
if ! tput colors >/dev/null 2>&1; then
    export TERM="xterm-256color"
fi

# 2. PATH & ENV
export LSP="$NK_BIN/lsp"
export ZSH="$NK_APPS/ohmyzsh"
export NVM_DIR="$HOME/.nvm"
export ZSH_CUSTOM="$ZSH/custom"

export GOOGLE_CLOUD_PROJECT="opencode-42"

if [[ "$UNAME_S" == "Darwin" ]]; then
    # Ajoute les chemins standards de Homebrew et de VS Code
    export PATH="/usr/local/bin:/opt/homebrew/bin:$PATH"
    export PATH="/Applications/Visual Studio Code.app/Contents/Resources/app/bin:$PATH"
fi
typeset -U path
path=($NK_BIN $HOME/.local/bin $HOME/.opencode/bin $HOME/.cargo/bin /usr/local/bin $path)

# 2. Vos dossiers perso (en fin de liste pour ne pas masquer les binaires systÃ¨me essentiels)
export PATH="$LSP:$NK_BIN:$PATH"

# --- AUTO-START ZELLIJ ---
# On ne lance Zellij que dans un shell interactif, hors de VS Code et si pas dÃ©jÃ  dans Zellij/Tmux
# if [[ -z "$ZELLIJ" ]] && [[ -z "$TMUX" ]] && [[ "$TERM_PROGRAM" != "vscode" ]] && command -v zellij >/dev/null 2>&1; then
#     exec zellij attach -c main
# fi

# 3. OH-MY-ZSH (Chargement silencieux)
ZSH_THEME="robbyrussell"
plugins=(git zsh-syntax-highlighting zsh-autosuggestions auto-notify you-should-use zsh-history-substring-search)
[ -f "$ZSH/oh-my-zsh.sh" ] && source "$ZSH/oh-my-zsh.sh"

if [[ "$OS_TYPE" == "linux" ]]; then
alias gfn='junest -f -- bash -c "cd ~/Downloads/squashfs-root && ./geforcenow-electron --no-sandbox"'

    export PATH="$PATH:~/.junest/usr/bin_wrappers"
    export PATH=~/.local/share/junest/bin:$PATH
fi

if [[ "$OS_TYPE" == "macos" ]]; then
    alias code='open -a "Visual Studio Code"'
fi
# 4. LOGIQUE VS CODE (WSL2)

if [[ "$OS_TYPE" == "wsl2" ]]; then
    unalias code c 2>/dev/null
    export VSCODE_EXE="/mnt/c/Users/kerma/AppData/Local/Programs/Microsoft VS Code/Code.exe"

    vscode() {
        # On encapsule tout dans un subshell ( ) pour cacher le job ID
        # On redirige tout vers /dev/null
        # Le & Ã  la fin du subshell dÃ©tache naturellement le processus
        ( "$VSCODE_EXE" --remote wsl+Ubuntu-22.04 "${@:-.}" &> /dev/null & )
    }
alias c='vscode'
fi

# 5. SMART-EDITOR
mkdir -p "$NK_BIN"
cat << 'EOF' > "$NK_BIN/smart-editor"
#!/usr/bin/env bash

# 1. Arguments par dÃ©faut
[ $# -eq 0 ] && set -- "."

W_CODE="/mnt/c/Users/kerma/AppData/Local/Programs/Microsoft VS Code/Code.exe"

if command -v nvim >/dev/null 2>&1; then
    exec nvim "$@"
fi

if grep -qiE 'microsoft|wsl' /proc/version 2>/dev/null; then
    if [[ -f "$W_CODE" ]]; then
        "$W_CODE" --remote wsl+Ubuntu-22.04 "$@" &> /dev/null &
        exit 0
    fi
fi

if [[ "$(uname -s)" == "Darwin" ]]; then
    if command -v code >/dev/null 2>&1; then
        open -a "Visual Studio Code" "$@"
        exit 0
    fi
fi

if command -v code >/dev/null 2>&1; then
    exec code "$@"
elif command -v zed >/dev/null 2>&1; then
    exec zed "$@"
elif command -v zed-editor >/dev/null 2>&1; then
    exec zed-editor "$@"
else
    exec vi "$@"
fi
EOF
chmod +x "$NK_BIN/smart-editor"

export EDITOR="smart-editor"
export VISUAL="smart-editor"

# Alias Ã©diteurs
alias z='zed'
alias edit='smart-editor'
alias e='smart-editor'
alias c='code'
alias v='vim'
alias n='nvim'

# Kitty SSH kitten
alias ssh="kitten ssh"

alias clear='clear -x'

# 6. FONCTIONS PERSO & AI
ai() {
    local search_cmd
    local hidden_flag=""

    # Gestion des arguments
    if [[ "$1" == "-a" ]]; then
        # On autorise les dossiers cachÃ©s (sauf .git et .cache)
        search_cmd="fd --type d --hidden --exclude .git --exclude .cache ."
    elif [[ -n "$1" ]]; then
        # Si un argument direct est passÃ© (ex: ai mon_dossier)
        opencode "$1"
        return
    else
        # Par dÃ©faut : dossiers visibles uniquement
        search_cmd="fd --type d ."
    fi

    local target=$(eval "$search_cmd" | fzf \
        --prompt="ó°š OpenCode (Local): " \
        --header="Select a folder to start agent")

    [[ -n "$target" ]] && cd "$target" && opencode .
}

# air : Recherche globale depuis le HOME (~/)
# air -a : Recherche globale incluant les dossiers cachÃ©s
air() {
    local search_cmd
    if [[ "$1" == "-a" ]]; then
        search_cmd="fd --type d --hidden . ~"
    else
        search_cmd="fd --type d --exclude .git --exclude .cache . ~"
    fi

    local target=$(eval "$search_cmd" | fzf \
        --prompt="ó°š OpenCode (Global ~/): " \
        --header="Search folders from home")

    [[ -n "$target" ]] && cd "$target" && opencode .
}

# Alias pour l'option -a (ouvre tout, mÃªme les fichiers cachÃ©s)
alias ai-all='ai'
alias aichat='opencode chat'
alias aip='opencode project'
alias aie='opencode explain'
alias gcm='~/.nkermani/scripts/gcm.sh'

# CAT / BAT
if command -v bat >/dev/null 2>&1; then
    alias cat='bat --style=plain --paging=never'
elif command -v batcat >/dev/null 2>&1; then
    alias cat='batcat --style=plain --paging=never'
fi

_get_viewer() {
    command -v bat >/dev/null 2>&1 && echo "bat --color=always --style=numbers" || \
        command -v batcat >/dev/null 2>&1 && echo "batcat --color=always --style=numbers" || \
        echo "cat"
}

# Navigation rapide dans le dossier courant
f() {
    local dir
    if [[ "$1" == "-a" ]]; then
        # Affiche TOUT (y compris les .files et .directories)
        dir=$(fd --type d --hidden --exclude .git --exclude .cache | fzf --prompt="ðŸ“‚ Go to (All): ")
    else
        # Cache les dossiers cachÃ©s
        dir=$(fd --type d --exclude .git --exclude .cache | fzf --prompt="ðŸ“‚ Go to: ")
    fi

    [[ -n "$dir" ]] && cd "$dir"
}

# Navigation rapide depuis le HOME
fr() {
    local dir
    if [[ "$1" == "-a" ]]; then
        # Recherche globale incluant les dossiers cachÃ©s
        dir=$(fd --type d --hidden . ~ | fzf --prompt="ðŸ“‚ Go to Home (All): ")
    else
        # Recherche globale standard
        dir=$(fd --type d --exclude .git --exclude .cache . ~ | fzf --prompt="ðŸ“‚ Go to Home: ")
    fi

    [[ -n "$dir" ]] && cd "$dir"
}

# --- Yazi (Terminal File Manager) ---
# Wrapper pour changer de rÃ©pertoire Ã  la fermeture
yy() {
    local tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
    yazi "$@" --cwd-file="$tmp"
    if cwd="$(cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
        builtin cd -- "$cwd"
    fi
    rm -f -- "$tmp"
}

# Alias y pour ouvrir yazi dans le dossier courant
alias y='yy .'

# Navigation Yazi via FZF (Current Path)
yf() {
    local dir
    if [[ "$1" == "-a" ]]; then
        dir=$(fd --type d --hidden --exclude .git --exclude .cache | fzf --prompt="ó°‡¥ Yazi (All): ")
    else
        dir=$(fd --type d --exclude .git --exclude .cache | fzf --prompt="ó°‡¥ Yazi: ")
    fi
    [[ -n "$dir" ]] && yy "$dir"
}

# Navigation Yazi via FZF (Home Path)
yfr() {
    local dir
    if [[ "$1" == "-a" ]]; then
        dir=$(fd --type d --hidden . ~ | fzf --prompt="ó°‡¥ Yazi Home (All): ")
    else
        dir=$(fd --type d --exclude .git --exclude .cache . ~ | fzf --prompt="ó°‡¥ Yazi Home: ")
    fi
    [[ -n "$dir" ]] && yy "$dir"
}

# FE : Find & Edit (Current Path)
fe() {
    local v=$(_get_viewer)
    local fd_cmd=("fd" "-a" "--type" "f" "--exclude" ".git" "--exclude" ".cache")
    local query=""

    # Gestion du flag -a
    if [[ "$1" == "-a" ]]; then
        fd_cmd+=("--hidden")
        query="$2" # On prend le mot suivant comme recherche fzf
    else
        query="$1"
    fi

    local file=$("${fd_cmd[@]}" | fzf --query "$query" --preview "$v {}")
    [[ -n "$file" ]] && smart-editor "$file"
}

# FRE : Find & Edit (Home Path)
fre() {
    local v=$(_get_viewer)
    local fd_cmd=("fd" "-a" "--type" "f")
    local query=""

    if [[ "$1" == "-a" ]]; then
        fd_cmd+=("--hidden")
        query="$2"
    else
        query="$1"
    fi
    # Force exclude heavy folders even with -a
    fd_cmd+=("--exclude" ".git" "--exclude" ".cache" "--exclude" "Library" "--exclude" "Music" "--exclude" "Movies" "--exclude" "Pictures" "--exclude" "Desktop" "--exclude" "Public" "--exclude" ".Trash")

    # On cherche dans le Home (~)
    local file=$("${fd_cmd[@]}" . ~ | fzf --query "$query" --preview "$v {}")
    [[ -n "$file" ]] && smart-editor "$file"
}

# --- Ouverture avec Code (smart-editor) ---
fo() {
    local dir
    local cmd="fd --type d --hidden --exclude .git --exclude .cache"
    [[ "$1" != "-a" ]] && cmd+=" --exclude '.*'"
    dir=$(eval "$cmd" | fzf --prompt="ðŸ’» Open with Code: ")
    # Utilise smart-editor pour gÃ©rer WSL/42/Linux
    [[ -n "$dir" ]] && smart-editor "$dir"
}

fro() {
    local dir
    local cmd="fd --type d --hidden"
    [[ "$1" == "-a" ]] && cmd+=""
    cmd+=" . ~"

    [[ "$1" != "-a" ]] && cmd+=" --exclude '.*'"
    dir=$(eval "$cmd" | fzf --prompt="ðŸ’» Open Home folder with Code: ")
    [[ -n "$dir" ]] && smart-editor "$dir"
}

_get_viewer() {
    if command -v bat >/dev/null 2>&1; then
        echo "bat --color=always --style=numbers --line-range :500"
    elif command -v batcat >/dev/null 2>&1; then
        echo "batcat --color=always --style=numbers --line-range :500"
    else
        echo "cat"
    fi
}

# FZF SEARCH FUNCTIONS
fcat() { local v=$(_get_viewer); local f=$(fd --type f --hidden --exclude .git --exclude .cache | fzf --preview "$v {}"); [[ -n "$f" ]] && cat "$f"; }
vf()   { local v=$(_get_viewer); local f=$(fd --type f --hidden --exclude .git --exclude .cache | fzf --preview "$v {}"); [[ -n "$f" ]] && smart-editor "$f"; }
vfg()  { local v=$(_get_viewer); local f=$(fd --type f --hidden --exclude .git --exclude .cache . ~ | fzf --preview "$v {}"); [[ -n "$f" ]] && smart-editor "$f"; }

# 7. INITIALISATIONS OPTIMISÃ‰ES (Lazy-loading)
# FZF & Zoxide
[ -n "$commands[fzf]" ] && source <(fzf --zsh 2>/dev/null || fzf --bash 2>/dev/null)
[ -n "$commands[zoxide]" ] && eval "$(zoxide init zsh)"

export FZF_DEFAULT_COMMAND='fd --type f --absolute-path'
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
export FZF_ALT_C_COMMAND='fd --type d --hidden'

# Dans ton .zshrc
if [ -d "/goinfre/$USER/.nvm" ]; then
    export NVM_DIR="/goinfre/$USER/.nvm"
else
    export NVM_DIR="$HOME/.nkermani/apps/nvm"
fi
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"

# NVM Lazy-load : Ne charge NVM que quand tu tapes 'nvm', 'node' ou 'npm'
if [ -s "$NVM_DIR/nvm.sh" ]; then
    nvm() {
        unfunction nvm node npm
        source "$NVM_DIR/nvm.sh"
        nvm "$@"
    }
node() {
    unfunction nvm node npm
    source "$NVM_DIR/nvm.sh"
    node "$@"
}
npm() {
    unfunction nvm node npm
    source "$NVM_DIR/nvm.sh"
    npm "$@"
}
fi

[ -f "$HOME/.cargo/env" ] && source "$HOME/.cargo/env"

# 8. ESTHÃ‰TIQUE
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=#808080'
bindkey '^?' backward-delete-char

# --- Section Notes ---
export NOTES_DIR="$NK_DIR/notes"

# On ne tente un pull que si c'est vraiment un repo git
if [ -d "$NOTES_DIR/.git" ]; then
    ( builtin cd "$NOTES_DIR" && git pull --quiet &> /dev/null & )
fi

alias brain="cd $NOTES_DIR && smart-editor $NOTES_DIR"
alias cdn="cd $NOTES_DIR"

[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

# bun completions
[ -s "/home/nkermani/.nkermani/apps/bun/_bun" ] && source "/home/nkermani/.nkermani/apps/bun/_bun"

# bun
export BUN_INSTALL="$HOME/.nkermani/apps/bun"
export PATH="$BUN_INSTALL/bin:$PATH"

alias gfn='junest -f -- bash -c "cd ~/Downloads/squashfs-root && ./geforcenow-electron --no-sandbox"'

