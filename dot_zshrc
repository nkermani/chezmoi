# ~/.zshrc - NKERMANI - Hybrid Config 2026
###############################################################################

# 1. D√âTECTION OS (Rapide)
UNAME_S=$(uname -s)
if [[ "$UNAME_S" == "Darwin" ]]; then
    OS_TYPE="macos"
elif grep -qiE 'microsoft|wsl' /proc/version 2>/dev/null; then
    OS_TYPE="wsl2"
else
    OS_TYPE="linux"
fi

export NK_DIR="$HOME/.nkermani"
export NK_APPS="$NK_DIR/apps"
export NK_BIN="$NK_DIR/bin"

# 2. PATH & ENV
export ZSH="$NK_APPS/ohmyzsh"
export NVM_DIR="$HOME/.nvm"

typeset -U path
path=($NK_BIN $HOME/.local/bin $HOME/.opencode/bin $HOME/.cargo/bin /usr/local/bin $path)

# 3. OH-MY-ZSH (Chargement silencieux)
ZSH_THEME="robbyrussell"
plugins=(git zsh-syntax-highlighting zsh-autosuggestions auto-notify you-should-use zsh-history-substring-search)
[ -f "$ZSH/oh-my-zsh.sh" ] && source "$ZSH/oh-my-zsh.sh"

if [[ "$OS_TYPE" == "wsl2" ]]; then
    unalias code c 2>/dev/null

    # On utilise export au lieu de readonly pour permettre le re-sourcing
    export VSCODE_EXE="/mnt/c/Users/kerma/AppData/Local/Programs/Microsoft VS Code/Code.exe"

    code() {
        "$VSCODE_EXE" --remote wsl+Ubuntu-22.04 "${@:-.}"
    }
    alias c='code'
else
    alias c='code'
fi

# 5. SMART-EDITOR (G√©n√©ration ultra-robuste)
W_CODE_EXE="/mnt/c/Users/kerma/AppData/Local/Programs/Microsoft VS Code/Code.exe"

mkdir -p "$NK_BIN"
cat << 'EOF' > "$NK_BIN/smart-editor"
#!/usr/bin/env bash

# Si aucun argument, on utilise le point (dossier actuel)
if [ $# -eq 0 ]; then
    set -- "."
fi

W_CODE="/mnt/c/Users/kerma/AppData/Local/Programs/Microsoft VS Code/Code.exe"

# Priorit√© WSL2
if [[ "$(grep -qiE 'microsoft|wsl' /proc/version 2>/dev/null && echo 'wsl')" == "wsl" ]]; then
    if [[ -f "$W_CODE" ]]; then
        # On passe les arguments exactement tels quels avec "$@"
        exec "$W_CODE" --remote wsl+Ubuntu-22.04 "$@"
        exit 0
    fi
fi

# Fallbacks
if command -v code >/dev/null 2>&1; then
    exec code "$@"
elif command -v nvim >/dev/null 2>&1; then
    exec nvim "$@"
else
    exec vi "$@"
fi
EOF
chmod +x "$NK_BIN/smart-editor"

export EDITOR="smart-editor"
export VISUAL="smart-editor"
# Alias √©diteurs
alias n='nvim'
alias vim='vim'
alias edit='smart-editor'
alias clear='clear -x'

# 6. FONCTIONS PERSO & AI
ai() {
  local dir=$(fd --type d --hidden --exclude .git . ~ | fzf --prompt="Û∞öù Launch OpenCode in: ")
  [[ -n "$dir" ]] && cd "$dir" && opencode
}
alias aichat='opencode chat'
alias aip='opencode project'
alias aie='opencode explain'

# CAT / BAT
if command -v bat >/dev/null 2>&1; then
    alias cat='bat --style=plain --paging=never'
elif command -v batcat >/dev/null 2>&1; then
    alias cat='batcat --style=plain --paging=never'
fi

_get_viewer() {
  command -v bat >/dev/null 2>&1 && echo "bat --color=always --style=numbers" || \
  command -v batcat >/dev/null 2>&1 && echo "batcat --color=always --style=numbers" || \
  echo "cat"
}

# FE : Find & Edit (Current Path)
fe() {
    local v=$(_get_viewer)
    local fd_cmd=("fd" "-a" "--type" "f" "--exclude" ".git")
    local query=""

    # Gestion du flag -a
    if [[ "$1" == "-a" ]]; then
        fd_cmd+=("--hidden" "--no-ignore")
        query="$2" # On prend le mot suivant comme recherche fzf
    else
        query="$1"
    fi

    local file=$("${fd_cmd[@]}" | fzf --query "$query" --preview "$v {}")
    [[ -n "$file" ]] && smart-editor "$file"
}

# FRE : Find & Edit (Home Path)
fre() {
    local v=$(_get_viewer)
    local fd_cmd=("fd" "-a" "--type" "f" "--exclude" ".git")
    local query=""

    if [[ "$1" == "-a" ]]; then
        fd_cmd+=("--hidden" "--no-ignore")
        query="$2"
    else
        query="$1"
    fi

    # On cherche dans le Home (~)
    local file=$("${fd_cmd[@]}" . ~ | fzf --query "$query" --preview "$v {}")
    [[ -n "$file" ]] && smart-editor "$file"
}

_get_viewer() {
    if command -v bat >/dev/null 2>&1; then
        echo "bat --color=always --style=numbers --line-range :500"
    elif command -v batcat >/dev/null 2>&1; then
        echo "batcat --color=always --style=numbers --line-range :500"
    else
        echo "cat"
    fi
}

# FZF SEARCH FUNCTIONS
fcat() { local v=$(_get_viewer); local f=$(fd --type f --hidden --exclude .git | fzf --preview "$v {}"); [[ -n "$f" ]] && cat "$f"; }
vf()   { local v=$(_get_viewer); local f=$(fd --type f --hidden --exclude .git | fzf --preview "$v {}"); [[ -n "$f" ]] && smart-editor "$f"; }
vfg()  { local v=$(_get_viewer); local f=$(fd --type f --hidden --exclude .git . ~ | fzf --preview "$v {}"); [[ -n "$f" ]] && smart-editor "$f"; }
# Nettoyage pr√©ventif
unalias f fr 2>/dev/null

# D√©finition des alias de navigation
alias f='cd $(fd --type d --hidden --exclude .git | fzf --prompt="üìÇ Go to: ")'
alias fr='cd $(fd --type d --hidden --exclude .git . ~ | fzf --prompt="üè† Go to (Home): ")'

# 7. INITIALISATIONS OPTIMIS√âES (Lazy-loading)
# FZF & Zoxide
[ -n "$commands[fzf]" ] && source <(fzf --zsh 2>/dev/null || fzf --bash 2>/dev/null)
[ -n "$commands[zoxide]" ] && eval "$(zoxide init zsh)"

# NVM Lazy-load : Ne charge NVM que quand tu tapes 'nvm', 'node' ou 'npm'
if [ -s "$NVM_DIR/nvm.sh" ]; then
    nvm() {
        unfunction nvm node npm
        source "$NVM_DIR/nvm.sh"
        nvm "$@"
    }
    node() {
        unfunction nvm node npm
        source "$NVM_DIR/nvm.sh"
        node "$@"
    }
    npm() {
        unfunction nvm node npm
        source "$NVM_DIR/nvm.sh"
        npm "$@"
    }
fi

[ -f "$HOME/.cargo/env" ] && source "$HOME/.cargo/env"

# 8. ESTH√âTIQUE
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=#808080'
bindkey '^?' backward-delete-char
